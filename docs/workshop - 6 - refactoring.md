### Лабораторно-практична робота №6

## Впровадження сервісного шару, валідації та DTO

**Мета**  
Навчитись проектувати та реалізовувати правильну архітектуру бекенд-додатку за принципом розділення відповідальності (Separation of Concerns). Практично реалізувати сервісний шар, впровадити механізм валідації через middleware та навчитись формувати контрольовані відповіді API за допомогою DTO.

### Контекст

На попередньому занятті ви реалізували базові CRUD-операції, але, скоріш за все, ваш код має кілька фундаментальних архітектурних недоліків, оскільки **контролер напряму взаємодіє з репозиторієм**. Це призводить до таких проблем:

1. **Порушення принципу єдиної відповідальності:** Контролер виконує занадто багато завдань — обробляє HTTP-запити, містить бізнес-логіку та працює з базою даних.
2. **Незахищеність:** Ваші ендпоінти не перевіряють дані, що надходять від клієнта.
3. **Неконтрольованість відповіді:** API повертає повну структуру entity з бази даних, розкриваючи внутрішні поля.

**Ваше завдання** — провести комплексний рефакторинг, виправити ці недоліки та привести архітектуру проекту у відповідність до сучасних практик.

### Етапи виконання роботи

#### 1\. Створення та впровадження сервісного шару

Це ключовий етап рефакторингу. Вам потрібно створити проміжний шар у вигляді **сервіс-класу**, який буде містити всю бізнес-логіку для роботи з конкретною сутністю.

- **Створіть файл сервісу.** Для кожної сутності створіть єдиний сервіс-клас (наприклад, `src/services/ProductService.ts`).
- **Реалізуйте клас-сервіс.** Цей клас повинен інкапсулювати всю логіку взаємодії з репозиторієм. Створіть у ньому методи для кожної операції (`create`, `findOne`, `findAll` тощо).
- **Перенесіть логіку з контролера.** **Виріжте всю логіку взаємодії з репозиторієм (`AppDataSource.getRepository(...)`) з функцій-контролерів** і перенесіть її у відповідні методи новоствореного сервіс-класу.
- **Оновіть контролери.** Тепер функції-контролери більше не повинні працювати з репозиторієм. Замість цього вони мають створювати екземпляр потрібного сервісу та викликати його методи.

**Приклад сервіс-класу:**

| // src/services/ProductService.tsimport { AppDataSource } from '../database/data-source';import { Product } from '../entities/Product'; // Ваша entityclass ProductService { private productRepository \= AppDataSource.getRepository(Product); async create(productData: { name: string; price: number }): Promise\<Product\> { const product \= this.productRepository.create(productData); await this.productRepository.save(product); return product; } async findOne(id: string): Promise\<Product\> { const product \= await this.productRepository.findOne({ where: { id } }); if (\!product) { // Тут можна обробити помилку "не знайдено" } return product; } // ... інші методи: findAll, update, delete}export { ProductService }; |
| :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

#### 2\. Створення Middleware-функції для валідації

Додайте перевірку вхідних даних, створюючи асинхронні middleware-функції.

- **Реалізуйте функцію-валідатор.** Створіть файл (наприклад, `src/middleware/validation/product/validatorCreateProduct.ts`) та експортуйте з нього `async` функцію, що перевіряє `req.body` за допомогою функцій з бібліотеки `validator` (`isEmpty`, `isFloat` тощо). У разі помилки функція має викидати `new AppError(...)`.
- **Підключіть middleware до роутів.** У файлах роутингу імпортуйте вашу функцію-валідатор і вставте її в ланцюжок обробки запиту **перед** викликом функції-контролера.

**Приклад middleware-функції:**

| // src/middleware/validation/product/validatorCreateProduct.tsimport { Request, Response, NextFunction } from 'express';import { isEmpty, isFloat } from 'validator';import { AppError } from '../../../../errors/AppError';export async function validatorCreateProduct(req: Request, \_res: Response, next: NextFunction): Promise\<void\> { const { name, price } \= req.body; if (isEmpty(name |     | '')) { throw new AppError('Product name is required'); } if (\!price |     | \!isFloat(String(price), { gt: 0 })) { throw new AppError('Price must be a number greater than 0'); } return next();} |
| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --- | -------------------------------------------------------------------- | --- | --------------------------------------------------------------------------------------------------------------------- |

#### 3\. Формування DTO у контролері

Зробіть відповіді вашого API контрольованими та безпечними.

- **Створіть клас DTO.** Створіть файл (наприклад, `src/dto/ProductResponseDTO.ts`), що описує публічну структуру відповіді. Його конструктор має приймати об'єкт entity.
- **Використовуйте DTO у контролері.** У функціях-контролерах, після отримання **entity від сервісу**, створіть екземпляр вашого `ResponseDTO` і поверніть саме його у відповіді клієнту.

**Приклад коду для ProductResponseDTO**

Цей клас відповідає за те, щоб відфільтрувати дані, отримані з бази даних, і повернути клієнту лише ту інформацію, яка є публічною. Він приймає повний об'єкт `Product` entity, але виставляє назовні лише обрані поля, при цьому їх можна перейменовувати для зручності клієнта API.

| // src/dto/ProductResponseDTO.tsimport { Product } from '../entities/Product'; // Ваша entityexport class ProductResponseDTO { id: string; productName: string; // Поле перейменовано з 'name' для API price: number; // Такі поля, як 'createdAt' та 'updatedAt' ми свідомо не включаємо у відповідь constructor(product: Product) { this.id \= product.id; this.productName \= product.name; this.price \= product.price; }} |
| :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

**Приклад фінальної архітектури (контролер \+ роут):**

| // src/controllers/product/findOneProduct.tsimport { Request, Response } from 'express';import { ProductService } from '../../services/ProductService';import { ProductResponseDTO } from '../../dto/ProductResponseDTO';export async function findOneProduct(req: Request, res: Response): Promise\<Response\> { const { id } \= req.params; // 1\. Контролер створює і викликає сервіс const productService \= new ProductService(); const productEntity \= await productService.findOne(id); // 2\. Контролер перетворює entity в DTO і повертає відповідь return res.json(new ProductResponseDTO(productEntity));}// src/routes/product.routes.tsimport { findOneProduct } from '../controllers/product/findOneProduct';// ...// Підключаємо функцію-контролер до роутуproductRoutes.get('/:id', findOneProduct); |
| :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

### Вимоги до результату

- Оновіть ваш **існуючий GitHub-репозиторій**.
- У файлі `README.md` додайте новий розділ, що описує **нову архітектуру** вашого додатку:
  1. Поясніть роль кожного шару: **Middleware** (валідація), **Controller** (оркестрація), **Service** (бізнес-логіка), **Repository** (доступ до даних).
  2. Наведіть приклад коду вашої middleware-функції.
  3. Наведіть приклад коду вашого `ResponseDTO` та сервіс-класу.
  4. Додайте скріншоти з Postman:
     - **Запит з некоректними даними**, який повертає помилку `400 Bad Request` від вашого middleware.
     - **Успішний запит**, відповідь на який має структуру вашого нового `ResponseDTO`.
